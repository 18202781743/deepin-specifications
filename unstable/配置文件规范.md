# 配置文件规范

* 维护者: zccrs <zhangjide@uniontech.com>
* 修改日期: 2021/2/24
* 版本: 1.0
* 参与讨论: https://gitlabwh.uniontech.com/wuhan/se/deepin-specifications/-/issues/3

## 名词解释

* 配置描述文件: 此类文件由安装包携带, 类似于 gsettings 的 schemes 文件, 用于描述配置项的元信息, 以及携带配置项的默认值
* 配置存储文件: 对于一些可修改的配置项, 存储文件用于保存程序运行过程中的改动

## 角色说明

* 应用程序: 读写配置文件的实体, 亦是配置文件的提供者, 一个应用程序可对应多个配置文件
* 配置文件: 包含一系列配置项的集合
* 配置中心: 为对外公开的配置项提供统一的管理服务, 实现配置项的override机制
* DTK: 应用程序开发基础库, 提供统一的配置文件读写接口

## 配置描述文件
使用json作为配置策略的描述文件

* 安装路径:
    * $APP_ROOT/configs/, 对应的真实路径为(以包格式标准为准) /opt/apps/foo.example/configs/
    * /usr/share/deepin/configs, 用于放置开发库所携带的描述文件, 如 /usr/share/deepin/com.deepin.dtk.core.json, 此目录下的配置描述文件为所有程序共享
* 文件名: {appid}.json, 如: foo.example.json
* 每一项配置可包含下列内容:
    * value: 配置项的默认值, 可使用json支持的各种数据类型
    * name: 配置项的可显示名称, 需国际化(可使用工具为其生成ts文件, ts编译后的qm文件需要与配置描述文件同名同路径放置). 此名称可用于展示到用户界面, 如当程序A请求通过配置中心读取程序B的某个配置项时, 将提示用户: 程序A请求获取程序B的"允许退出"配置项的值, 是否允许?, 用户可选择拒绝程序A的请求.
    * description: 描述此配置项的用途, 需国际化(同name)
    * permissions: 配置项的权限
        * readonly: 不允许修改, 当程序读取此配置时, 将直接使用默认值
        * readwrite: 可读可写, 如果此值被修改过, 则不再使用此处定义的默认值
    * visibility: 配置项的可见性
        * private 仅限程序内部使用, 对外不可见
        * public 外部程序可使用
    * flags: 配置项的一些特性(数组类型)
        * no-override: 是否允许外部覆盖(详见下述"override机制"), 如果存在此flag, 则此配置项不可被覆盖
        * global: 不区分用户, 被修改时将对所有用户生效

$APP_ROOT/configs/foo.example.json示例
````
{
    "magic": "deepin/config",
    "version": "1.0",
    "contents": {
        "key1": {
            "value": value1,
            "name": "允许退出"
            "description": "xxxxxxxx",
            "permissions": "readwrite",
            "visibility": "private"
            "flags": ["override"]
        }
    }
}
````

### override机制(以$APP_ROOT/configs/foo.example.json为例)
* override文件放置路径:
    * /usr/share/deepin/configs/overrides/foo.example/foo.example/
    * /usr/share/deepin/configs/overrides/com.deepin.dtk.core/
    * /etc/deepin/configs/overrides/foo.example/foo.example/
    * /etc/deepin/configs/overrides/com.deepin.dtk.core/ 此处在overrides路径后省略了appid目录, 表示为所有应用程序提供对 com.deepin.dtk.core 配置的覆盖
* /usr/share 下的路径用于安装deb包携带的文件
* /etc 下的路径用于防止动态创建的文件, 比如用户手动添加, 或者域管下发, 它的优先级高于 /usr/share 的目录
* 文件名无限制, 以 ".json" 结尾即可, 按文件名排序, 越靠后的配置文件优先级越大
* 可以覆盖配置项的 "value" "permissions" 两个属性, 以 /etc/deepin/config/overrides/foo.example/foo.example/oem1-override.json 为例, 每一项配置可包含下列内容:
    * value: 覆盖配置项的默认值
    * comment: 为此override行为添加一些注释
    * permissions: 覆盖配置项的权限
        * readonly: 将配置项覆盖为只读
        * readwrite: 将配置项覆盖为可读可写值
````
{
    "magic": "deepin/config",
    "version": "1.0",
    "contents": {
        "key1": {
            "value": value1,
            "comment": "xxxxxxxx",
            "permissions": "readonly"
        }
    }
}
````

## 配置存储文件
使用json作为配置文件的存储格式, 根据配置项是否为global级别, 分别存储在:
* 用户级别: $HOME/.config/foo.example/foo.example.json
* global级别: /deepin/data/foo.example/configs/foo.example.json

以 $HOME/.configs/foo.example/foo.example.json 为例, 配置存储格式如下: 此文件内容用于存储程序的运行时修改的配置内容, 不要往此目录安装任何文件.
* value: 保存修改后的值
* time: 值的保存时间, 使用UTC时间, 采用 ISO 8601 表示方法
* user: 被哪个用户所修改, 对global类型的配置项有意义
````
{
    "magic": "deepin/config",
    "version": "1.0",
    "contents": {
        "key1": {
            "value": value1,
            "time": "2017-07-24T15:46:29",
            "user": "user name"
        }
    }
}
````

## 配置中心规范
### 引言
此草案定义了上述配置文件的管理服务, 对外提供配置项的读写接口. 基于DBus服务实现, 关于DBus的规范请查看: https://dbus.freedesktop.org/doc/dbus-specification.html

### 与程序的关系
当配置中心的DBus服务存在时(需要注意, 仅需要它存在, 不要求它一定处于运行状态), 所有配置项的读写皆要通过此服务进行

### 配置中心的DBus接口
````
<interface name='com.deepin.ConfigManager'>
    <method name='getManager'>
      <arg type='s' name='appid' direction='in'/>
      <arg type='s' name='name' direction='in'/>
      <arg type='o' name='path' direction='out'/>
    </method>
    <method name='releaseManager'>
      <arg type='s' name='name' direction='in'/>
    </method>
</interface>
<interface name='com.deepin.ConfigManager.Manager'>
    property access="read" type="s" name="version"/>
    property access="read" type="as" name="keyList"/>
    <!--为每个key提供一个只读属性, 如:
    property access="read" type="v" name="key1"/>
    ...
    property access="read" type="v" name="key2"/>
    -->
    <method name='value'>
      <arg type='s' name='key' direction='in'/>
      <arg type='v' name='value' direction='out'/>
    </method>
    <method name='setValue'>
      <arg type='s' name='key' direction='in'/>
      <arg type='v' name='value' direction='in'/>
    </method>
    <method name='permissions'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='permission' direction='out'/>
    </method>
    <method name='name'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='language' direction='in'/>
      <arg type='s' name='name' direction='out'/>
    </method>
    <method name='description'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='language' direction='in'/>
      <arg type='s' name='description' direction='out'/>
    </method>
    <method name='visibility'>
      <arg type='s' name='key' direction='in'/>
      <arg type='s' name='visibility' direction='out'/>
    </method>
    <signal name="valueChanged">
      <arg name="key" type="s" direction="out"/>'
    </signal>
</interface>
````

## API接口规范
### 引言